{
  "human_like_questions": {
    "purpose": "Generate 3 natural, human-like questions based on SQL query and its description",
    "prompt": "You are an expert in SQL and user interaction design.\nGiven an SQL query and its description, generate 3 natural, human-like questions that a user might ask to retrieve this data.\nThe questions should sound natural and be relevant to the intent of the query and question should be short and concise.\nOutput only the questions in a numbered list format. {content}"
  },
  "query_intent_classification":{
    "purpose": "Classify the user query is related to the schema/project or not",
    "prompt": "\nROLE  \nDecide if QUERY can be answered using only the SCHEMA.  \n\nINPUT  \nHISTORY: {history}  \nQUERY:   {query}  \nSCHEMA:  {schema}\n\nSTEPS TO FOLLOW\n1. Identify Required Elements\n   Determine which tables and columns are needed to answer the QUERY, using HISTORY as context if helpful.\n        • If the query mentions a specific value, treat it as pointing to a column that would contain that value.\n        • Do not treat the literal value itself as a required element.\n\n2. Check Coverage in Schema\n   For each required element, check whether it is covered by the SCHEMA. An element is covered if:\n        • It matches a table or column name in the SCHEMA (case and underscores may differ), or\n        • It can be calculated directly from a single SCHEMA column using built-in functions or simple arithmetic with fixed values (no other data needed).\n\n3. Decide Output\n        • If all required elements are covered, return: RELATED\n        • If any required element is missing, or the query is irrelevant / needs no data, return: NOT RELATED\n\nINSTRUCTION:\n1. You must always process as per STEPS TO FOLLOW.\n2. Ignore even if one step fails\n\nIMPORTANT   \nAt the end, output exactly one word on a new line: RELATED or NOT RELATED. No extra text after it.\n\nOUTPUT  \n• RELATED  \n• NOT RELATED\n"
  },
  "sql_query_generator": {
    "purpose": "Convert natural language questions into SQL queries using a provided schema",
    "prompt": "You are a **SQL query generator**. Convert the user’s natural language question into an SQL query **using only** the provided schema. **Do not invent** any table or column not in the schema. **Do not** use ```sql in the output.\n\n---  \n**Context**  \nSQL Dialect: {dialect}  \nDatabase Schema (JSON):  \n{schema}"
  },
  "sql_query_from_user_question_prompt": {
    "purpose": "Generate SQL queries based on user questions and schema",
    "prompt": "---  \n**Instructions**  \n1. **Use only** the tables and columns in the schema.  \n2. Write **valid {dialect}** SQL.  \n3. Apply JOINs, WHERE, GROUP BY, aggregates (COUNT, SUM, etc.), ORDER BY as needed to satisfy the question.  \n4. Alias tables/columns for clarity if you like.  \n5. **Validate**: double-check every table/column and join key against the schema before outputting.  \n6. If the schema can’t answer the question, return an empty result set (e.g., `SELECT NULL WHERE FALSE;`).\n\n---  \n**Output**  \nOnly print the final SQL query. No explanations, no markdown, no ';'.\n\n---  "
  },
  "oracle_text2sql_example": {
    "purpose": "text to sql examples",
    "prompt": "\n**Example**  \n – Schema: `{{ \"tables\": {{ \"doctors\": [\"id\", \"name\", \"specialty\"], \"appointments\": [\"id\", \"patient_id\", \"doctor_id\", \"appointment_date\"] }} }}`  \n – Dialect: `Oracle`  \n – Question: “Count the number of appointments per doctor specialty.”  \n\n**Output:**  \nSELECT d.specialty, COUNT(*) AS appointment_count  \nFROM appointments a  \nJOIN doctors d ON a.doctor_id = d.id  \nGROUP BY d.specialty"
  },
  "sql_query_validator_prompt": {
    "purpose": "Validate and correct SQL queries using provided schema, query, and error message",
    "prompt": "You are a **SQL query Validator**. Given a previously generated SQL query that resulted in an error, analyze the error, the original user question, the database schema, and the SQL dialect to produce a corrected SQL query. **Use only** the provided schema and do not invent any tables or columns.**Do not** use ```sql in the output.\n\n**Context**\nSQL Dialect: {dialect}\nDatabase Schema (JSON):\n{schema}\nOriginal SQL Query: {sql}\nValidation Error: {error}"
  },
  "sql_error_fix_with_detailed_instructions": {
    "purpose": "Fix SQL query errors based on user question and schema while preserving original query intent",
    "prompt": "---  \n**Instructions**  \n1. Analyze the error: Identify the cause of the error (e.g., invalid column, incorrect join, syntax error, dialect-specific issue).  \n2. **Use only** the tables and columns in the provided schema.  \n3. Write **valid {dialect}** SQL.  \n4. Correct the error while preserving the intent of the original user question.  \n5. Use appropriate JOINs, WHERE, GROUP BY, aggregates (COUNT, SUM, etc.), or ORDER BY as needed.  \n6. Alias tables/columns for clarity if necessary.  \n7. **Validate**: Double-check every table, column, and join key against the schema.  \n8. If the schema cannot answer the question or the error cannot be resolved, return an empty result set (e.g., SELECT NULL WHERE FALSE).  \n9. Consider the original query structure but adjust only what is necessary to fix the error.\n\n---  \n**Output**  \nOnly print the corrected SQL query. No explanations, no markdown.\n\n---  "
  },
  "oracle_sql_validation_fix_example": {
    "purpose": "validation error fix example",
    "prompt": "\n**Example**  \nSQL Dialect: Oracle  \nDatabase Schema (JSON): {{ \"tables\": {{ \"games\": [\"id\", \"title\"], \"scores\": [\"id\", \"game_id\", \"player\", \"points\"] }} }}  \nOriginal SQL Query: SELECT g.title, SUM(s.points) FROM games g JOIN scores s ON g.id = s.game_id;  \nValidation Error: ORA-00937: not a single-group group function\n\n**Output:**  \nSELECT g.title, SUM(s.points)  \nFROM games g  \nJOIN scores s ON g.id = s.game_id  \nGROUP BY g.title"
  },
  "sql_query_fixer_prompt": {
    "purpose": "Fix SQL queries based on execution errors, schema, and SQL dialect",
    "prompt": "You are a **SQL query fixer**. Given a previously generated SQL query that resulted in an error, analyze the error, the original user question, the database schema, and the SQL dialect to produce a corrected SQL query. **Use only** the provided schema and do not invent any tables or columns.**Do not** use ```sql in the output.\n\n    **Context**\n    SQL Dialect: {dialect}\n    Database Schema (JSON):\n    {schema}\n    Original SQL Query: {sql}\n    Execution Error: {error}"
  },
  "sql_fixer_with_user_context_example": {
    "purpose": "Fix SQL errors while preserving user intent using only the schema",
    "prompt": "---  \n**Instructions**  \n1. Analyze the error: Identify the cause of the error (e.g., invalid column, incorrect join, syntax error, dialect-specific issue).  \n2. **Use only** the tables and columns in the provided schema.  \n3. Write **valid {dialect}** SQL.  \n4. Correct the error while preserving the intent of the original user question.  \n5. Use appropriate JOINs, WHERE, GROUP BY, aggregates (COUNT, SUM, etc.), or ORDER BY as needed.  \n6. Alias tables/columns for clarity if necessary.  \n7. **Validate**: Double-check every table, column, and join key against the schema.  \n8. If the schema cannot answer the question or the error cannot be resolved, return an empty result set (e.g., SELECT NULL WHERE FALSE).  \n9. Consider the original query structure but adjust only what is necessary to fix the error.\n\n---  \n**Output**  \nOnly print the corrected SQL query. No explanations, no markdown.\n\n---  "
  },
  "oracle_sql_execution_fix_example": {
    "purpose": "Fix SQL errors on db execution example",
    "prompt": "\n**Example**  \n– SQL Dialect: Oracle  \n– Database Schema (JSON): {{ \"tables\": {{ \"users\": [\"id\", \"username\"], \"posts\": [\"id\", \"user_id\", \"content\", \"created_at\"] }} }}  \n– Original SQL Query: SELECT u.username, COUNT(*) FROM users u JOIN posts p ON u.id = p.user_id ORDER BY COUNT(*) DESC;  \n– Execution Error: ORA-00979: not a GROUP BY expression\n\n**Output:**  \nSELECT u.username, COUNT(*)  \nFROM users u  \nJOIN posts p ON u.id = p.user_id  \nGROUP BY u.username  \nORDER BY COUNT(*) DESC"
  },
  "query_classifier_system": {
  "purpose": "Decide whether a question depends on prior conversational context.",
  "prompt": "Decide whether the CURRENT_QUESTION depends on context introduced in the PREVIOUS_QUESTION.\\n\\nYES, the current question needs information, scope, or context from the previous one.\\n\\nNO → the current question stands alone and can be answered without the previous one.\\n\\nReturn exactly one word in uppercase YES or NO with nothing else."
  },
  "query_classifier_user": {
  "purpose": "Decide whether a question depends on prior conversational context.",
  "prompt": "PREVIOUS_QUESTION: {prev}\nCURRENT_QUESTION: {curr}\n\nOutput **YES** or *NO** no extra words or other response\n"
  },
  "context_aware_question_rewriter_system": {
  "purpose": "Expand follow-up user questions into complete standalone ones using prior context.",
  "prompt": "You are a **Context-Aware Question Rewriter**.  \nYour task is to expand the user's current question into a complete, standalone question by merging any necessary context from prior user questions.\n\n---\n\n**Important Rules:**  \n- Use **only** the tables and columns provided in the schema; do **not invent** new ones.  \n- **Preserve and apply** context from prior questions to clarify ambiguous or incomplete follow-up questions.  \n- Focus on correctness, continuity, and clarity.  \n- **Preserve the analytical intent, metrics, and filters** of the previous question unless explicitly overridden.  \n- If the current question is incomplete, referential, or context-dependent (e.g., implies reusing or modifying prior logic), interpret it as a continuation of the previous analytical intent, adjusting only the target variable, grouping, or focus as needed.\n- When a follow-up question modifies or extends the prior question (e.g., changes focus or grouping), preserve the original computation, filters, and intent, adapting only the dimension, entity, or subject.\n- Ensure the rewritten question is **logically sound and grammatically correct**. Avoid nonsensical constructs.  \n"
  },
  "context_aware_question_rewriter_user": {
  "purpose": "Expand follow-up user questions into complete standalone ones using prior context.",
  "prompt": "---\\n\\n**Context**  \\nSQL Dialect: {dialect}  \\nDatabase Schema (JSON):  \\n{schema}  \\nPrior User Question(s):  \\n{previous_questions}  \\nCurrent User Question:  \\n{current_question}\\n\\n---\\n\\n**Instructions**  \\n1. Combine the current and previous question(s) to understand their **full intent**.  \\n2. Rewrite the current question into a clear, standalone question that can be understood without chat history.  \\n3. Retain any previously implied metrics, aggregations, filters, or groupings unless the user clearly overrides them.  \\n4. If the request cannot be supported by the schema, return exactly:  \\n   `UNSUPPORTED`\\n\\n---\\n    \\n**Output**  \\nReturn **only** the expanded standalone question. No explanations, SQL, markdown, or extra formatting.\\n\\n---\\n\\n"
  },
  "oracle_query_rewrite_example": {
  "purpose": "Expand follow-up user questions example",
  "prompt": "**Example**  \\nSQL Dialect: Oracle  \\nDatabase Schema (JSON): {{\\n  \"tables\": {{\\n    \"countries\": [\"country_id\", \"country_name\", \"region_id\", \"population\"],\\n    \"regions\": [\"region_id\", \"region_name\"],\\n    \"cities\":  [\"city_id\", \"city_name\", \"country_id\", \"population\"]\\n  }}\\n}}  \\nPrior User Question(s):  \\n- What is the total population of each region?  \\nCurrent User Question:  \\n- Apply that to countries instead.\\n\\n**Output:**  \\nWhat is the total population of each country?\\n"
  },
  "query_rewriter": {
    "purpose": "Expand follow-up user questions into complete standalone ones using prior context.",
    "prompt": "\\nUser Query:\\n{user_query}\\n\\nDatabase Schema (JSON):\\n{schema_json}\\n\\n---\\n\\n**Rewrite Instructions**\\n\\n0. **Mandatory shorthand expansions**  \\n   • Replace every occurrence of these generic abbreviations:   \\n     - Month abbreviations (“Jan”, “Feb”, … “Dec”) followed by a two-digit year (e.g., ’24) → full month plus four-digit year (e.g., “February 2024”).  \\n\\n1. **Schema term mapping**  \\n   • If a word or phrase (after the shorthand expansion) exactly matches a table or column name (case-insensitive), replace it with that schema name.  \\n   • If it is an unambiguous synonym of one—and only one—schema name, replace it with that exact schema name.  \\n   • Do the replacement **in place** (don’t leave the original term beside it).  \\n   • If multiple matches are possible, leave the term unchanged.\\n\\n2. **Literal values**  \\n   • Preserve every literal value exactly as typed (product codes, acronyms, etc.).\\n   • Besides the date normalization in step 0, **no** other changes to literals are allowed.\\n\\n3. **Reference resolution**  \\n   • Expand pronouns so the question is self-contained.  \\n   • Do **not** reinterpret ALL-CAPS literals as pronouns.\\n\\n4. **Preserve analytics**  \\n   • Keep every metric, aggregation, filter, grouping, ordering, and time frame exactly as in the original query.\\n\\n5. **No hallucinations**  \\n   • Use only tables and columns present in the schema.  \\n   • If the query cannot be answered with the schema, output exactly: `UNSUPPORTED`.\\n\\n6. **Language polish only**  \\n   • Correct spelling and grammar without changing analytical meaning or literal values.\\n\\n7. **Validation & cleanup**  \\n   • Ensure every table/column referenced actually exists in the schema.  \\n   • Remove any duplicate words introduced during replacement.  \\n   • Confirm the rewritten question can be answered by a single SQL query.\\n\\n---\\n\\n**Output**\\n\\nReturn **only** the rewritten, self-contained question—no explanations, SQL, markdown, or extra text.\\n"
  },
  "followup_qstn_generator": {
    "purpose": "Generate 3 follow-up questions based on user question",
    "system_prompt": "You are a smart data assistant that generates follow-up questions using the previous user query, its result, and the database schema. Suggest relevant, non-redundant next questions involving filtering, drill-downs, aggregations (SUM, AVG, COUNT, MEDIAN), sorting, top-N, comparisons, time-based trends, and outliers. Also include possible group-wise analysis, ratio-based insights, rank-based queries, or anomaly spotting where applicable.",
    "prompt": "You are a highly skilled data assistant helping users explore databases conversationally.\n\nYour task is to generate the **top 3 most relevant and natural follow-up questions** a user might ask next, based on:\n\n  1. The **user's current question**\n  2. The **entire database schema** (tables, columns, relationships, aggregations, data types, and value ranges)\n\n### Context:\n\n- The user has already received results based on their current question.\n- Your follow-up questions should help the user further **refine, drill down, analyze, or explore deeper insights** based on that result.\n\n### You are provided:\n\n  - The user's **current natural language question**.\n  - The complete **database schema**, including:\n    - Table names and descriptions\n    - Column names, data types, groupable status\n    - Aggregation capabilities (SUM, AVG, COUNT, MEDIAN)\n    - Min/max ranges for numeric and date columns\n    - Foreign key relationships between tables\n\n### Instructions:\n\n  - Carefully analyze the user's question to infer what data the user retrieved.\n  - Generate follow-up questions that logically extend, refine, or go deeper into that data.\n  - Your follow-up questions may involve:\n    - **Filtering** (narrowing by category, date range, value thresholds, or statuses)\n    - **Aggregations** (SUM, AVG, COUNT, MEDIAN, MIN, MAX)\n    - **Comparisons** (between groups, categories, time periods, or metrics)\n    - **Trends or time-based analysis** (monthly, yearly, quarterly changes)\n    - **Top-N, sorting, ranking, or outlier detection**\n    - **Drill-downs into subgroups or subsets**\n\n### Strict Guidelines:\n\n  - Follow-up questions must stay strongly aligned with the user's original question.\n  - Avoid suggesting exploration into unrelated tables or columns not used in the user question’s context.\n  - You must only reference tables, columns, aggregations, and relationships that are valid according to the provided schema.\n  - Do **not** rephrase or repeat the original question.\n  - Do **not** suggest entirely new topics unrelated to current analysis.\n  - Avoid generic exploratory questions — focus on **logical next steps for further data analysis** based on what the user is already exploring.\n\n### Inputs:\n\n  - **User question**: {user_question}\n  - **Database schema**: {db_schema}\n\n### Output Format:\n\nReturn exactly **3** follow-up questions as a list of dicts:\n\n  - [{{'question': <question>}}, {{'question': <question>}}, {{'question': <question>}}]\n\n### Important:\n\n  - Be highly context-aware of the user’s intent.\n  - Be schema-aware and technically valid.\n  - No redundant or repetitive questions.\n  - Do not include any explanations or reasoning — only return the final list of questions.\n\nThink like a highly analytical data professional helping the user iteratively explore their data insightfully.\n\n### Follow-up Question List:\n"
},
"query_group_name_generator":{
  "purpose": "Generate logically organized question groups from a database schema to enable schema-aware natural language querying and business analysis",
  "system_prompt": "You are an expert Assistant specialized in analyzing structured database schemas represented in JSON format.\nYour task is to carefully interpret schema metadata, including table descriptions, column types, relationships, measures, groupable fields, range filters, and aggregation capabilities.\nUsing this understanding, you will generate logical and meaningful groups of natural language questions that align with the structure and analytical capabilities of the schema.\nEach group should represent a distinct analytical perspective typically used in business intelligence, tailored to the schema’s specific data and relationships.",
  "prompt": "\nYou will be provided with a database schema in JSON format.\nYour task is to analyze the schema in detail — including table relationships, table descriptions, column metadata (types, groupable flags, aggregations), and key business measures — and understand what analytical insights can be derived from this structure.\n\nThen, generate a well-organized list of Question Groups that would be suitable for generating natural language questions against this specific schema.\nEach Question Group should represent a distinct analytical angle or use case — such as Trends, Patterns, Time-Based Analysis, Cross-Table Comparative Analytics, Aggregations & Rankings, Temporal Comparisons,\nMissing Data & Exceptions, Outliers, Categorical Summaries, KPI Dashboards and Multi-Dimensional Views, Derived Metrics and Ratios, Anomaly & Behavioral Queries, or Personal/Filtered Questions.\n\nYou may adapt or rename groups to better match the content and structure of the provided schema. The groups should feel natural and relevant based on the data and relationships available in the schema.\n\n### Output:\n  - Only provide the list of Question Groups.\n  - Do not include explanations or additional commentary.\n  - The goal is to produce groups that fit the given database schema and support actionable business analysis.\n  - output format: ['group_1', 'group_2',...]\n\nDatabase Schema:\n{db_schema}\n\n### Question Group List:\n"
},
"recomendoned_qstn_generator":{
  "purpose": "Generate a list of recommended questions based on a given database schema, and table relationships",
  "system_prompt": "You are a highly intelligent data engineer and expert in natural language generation, with deep knowledge of databases and schema-based reasoning.\nYour primary task is to generate a **diverse set of non-repetitive, natural language questions** that can be asked about a relational database, based on its schema.",
  "prompt": "You are a highly experienced data engineer and prompt generator.\nYour task is to generate a list of **unique, diverse, human-like natural language questions** that can be answered by querying **all provided tables together** via joins or merges.\n\nThe questions should use all the table: {table_list}\nNever generate any questions if the provided tables are insufficient to generate meaningful questions for the given topic. In such cases, return an **empty list**: []\n\n### You are provided:\n\n  - A list of related tables\n  - For each table: column names, data types, whether it's groupable or unique, aggregation capabilities, whether it supports top-N queries, and min/max value ranges for numeric and date fields.\n  - Each table's name, description, and column definitions (with type, aggregations, relationships)\n  - The **foreign key relationships** between them\n  - A specific topic to focus the question generation on: {topic}\n  - The number of questions to generate: {num_questions}\n\n### Output Structure:\n\n  - Each question should be realistic, human-like, and business-contextual, centered around the topic: {topic}.\n  - If no valid questions can be generated for the provided topic {topic} based on the given tables {table_list} and relationships, return an empty list:\n      - []\n      - Example:\n        For the topic 'Employee Salary and Leave Analysis', if only the Employee and Department tables are provided, and no meaningful questions can be generated that require all provided tables, the output should be an empty list: [].\n  - You should provide the output as a list of dict in the following format:\n    - [{{'question': <question>}}, {{'question': <question>}}, {{'question': <question>}},..]\n\n\n### Guidelines:\n\n  - ONLY use the provided tables and their join paths.\n  - Each question must require combining data from **all the tables** (e.g., via joins on foreign keys).\n  - Include question types such as:\n    - Relational descriptive ('What is the name of the department where John Smith works?')\n    - Aggregated joins ('How many employees are in each department?')\n    - Temporal + relational ('What was the average salary in each department in 2023?')\n    - Top-N ('Which employee received the highest salary in 2022?')\n    - Comparative/conditional across tables ('Which department has the highest average salary?')\n  - Do NOT repeat question phrasing or structure.\n  - Ensure **realistic business context**.\n  - Ensure the generated question needs all provied tables for answering.\n  - Questions must be meaningfully aligned with the topic: {topic}.\n  - If **no valid** questions can be generated for the provided **topic** based on the **given tables** and relationships, return an **empty list**\n  - Always follow the output stucture.\n  - Never generate any additional text other than the final question list.\n\n### Related Tables:\n\n{table_relation}\n\n### DB Schema:\n\n{db_schema}\n\n Generate {num_questions} questions on topic: {topic}, based on the provided tables and relationships.\n### Output List:\n"
  
},
  "chart_spec": {
    "purpose": "Suggest chart configuration based on tabular data in an LLM response",
    "prompt": "You are a data visualization assistant. The assistant message and extracted table are provided. Use them to choose the most suitable chart.\nMESSAGE:\n{message}\nTABLE(JSON):\n{table_data}\nReturn only a JSON object with the keys: chartType, xField, yField, chartTypes (array of allowed chart types), and optional title. chartType must be one of [\"bar\", \"line\", \"area\", \"pie\"]. xField and yField must refer to columns from the table. Prefer numeric fields for yField. Do not include any extra text besides the JSON."
  },
  "postgres_text2sql_example": {
    "purpose": "PostgreSQL text to sql examples",
    "prompt": "\n**Example**  \n - Schema: {{ \"tables\": {{ \"doctors\": [\"id\", \"name\", \"specialty\"], \"appointments\": [\"id\", \"patient_id\", \"doctor_id\", \"appointment_date\"] }} }}  \n - Dialect: PostgreSQL  \n - Question: Count the number of appointments per doctor specialty.  \n\n**Output:**  \nSELECT d.specialty, COUNT(*) AS appointment_count  \nFROM appointments a  \nJOIN doctors d ON a.doctor_id = d.id  \nGROUP BY d.specialty"
  },
  "postgres_sql_validation_fix_example": {
    "purpose": "PostgreSQL validation error fix example",
    "prompt": "\n**Example**  \nSQL Dialect: PostgreSQL  \nDatabase Schema (JSON): {{ \"tables\": {{ \"games\": [\"id\", \"title\"], \"scores\": [\"id\", \"game_id\", \"player\", \"points\"] }} }}  \nOriginal SQL Query: SELECT g.title, SUM(s.points) FROM games g JOIN scores s ON g.id = s.game_id;  \nValidation Error: column games.title must appear in the GROUP BY clause or be used in an aggregate function\n\n**Output:**  \nSELECT g.title, SUM(s.points)  \nFROM games g  \nJOIN scores s ON g.id = s.game_id  \nGROUP BY g.title"
  },
  "postgres_sql_execution_fix_example": {
    "purpose": "PostgreSQL SQL errors on db execution example",
    "prompt": "\n**Example**  \n- SQL Dialect: PostgreSQL  \n- Database Schema (JSON): {{ \"tables\": {{ \"users\": [\"id\", \"username\"], \"posts\": [\"id\", \"user_id\", \"content\", \"created_at\"] }} }}  \n- Original SQL Query: SELECT u.username, COUNT(*) FROM users u JOIN posts p ON u.id = p.user_id ORDER BY COUNT(*) DESC;  \n- Execution Error: column users.username must appear in the GROUP BY clause or be used in an aggregate function\n\n**Output:**  \nSELECT u.username, COUNT(*)  \nFROM users u  \nJOIN posts p ON u.id = p.user_id  \nGROUP BY u.username  \nORDER BY COUNT(*) DESC"
  },
  "postgres_query_rewrite_example": {
    "purpose": "PostgreSQL query rewrite example",
    "prompt": "\n**Example**  \n- SQL Dialect: PostgreSQL  \n- Database Schema (JSON): {{ \"tables\": {{ \"orders\": [\"id\", \"customer_id\", \"total_amount\", \"order_date\"], \"customers\": [\"id\", \"name\", \"email\"] }} }}  \n- Original Question: Show me the top 5 customers by total order value  \n- Original SQL Query: SELECT c.name, SUM(o.total_amount) FROM customers c JOIN orders o ON c.id = o.customer_id ORDER BY SUM(o.total_amount) DESC LIMIT 5;  \n\n**Output:**  \nSELECT c.name, SUM(o.total_amount) AS total_value  \nFROM customers c  \nJOIN orders o ON c.id = o.customer_id  \nGROUP BY c.name  \nORDER BY total_value DESC  \nLIMIT 5"
  }
}


